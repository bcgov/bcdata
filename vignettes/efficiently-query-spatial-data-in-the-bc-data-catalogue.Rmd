---
title: "Querying Spatial Data with bcdata"
date: "2020-02-12"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Querying Spatial Data with bcdata}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!--
Copyright 2019 Province of British Columbia

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
-->




This vignette illustrates how to use `bcdata::bcdc_query_geodata` to request and query [Web Service-enabled](https://www2.gov.bc.ca/gov/content?id=95D78D544B244F34B89223EF069DF74E) geospatial data from the B.C. Data Catalogue. To illustrate, we will request and merge two spatial datasets from the catalogue---school district and greenspaces spatial data---and then examine the amount of park space contained within the boundaries of the Greater Victoria, Prince George and Kamloops/Thompson British Columbia school districts.

## Getting Started
First you need to load the package. We will also load the `sf` and `dplyr` packages to help us work with spatial data. You can learn more about the `sf` package [here](https://r-spatial.github.io/sf/) and `dplyr` [here](https://dplyr.tidyverse.org/):


```r
library(bcdata)
library(sf)
#> Linking to GEOS 3.7.2, GDAL 2.4.2, PROJ 5.2.0
library(dplyr)
#> 
#> Attaching package: 'dplyr'
#> The following objects are masked from 'package:stats':
#> 
#>     filter, lag
#> The following objects are masked from 'package:base':
#> 
#>     intersect, setdiff, setequal, union

getwd()
#> [1] "/Users/runner/runners/2.164.0/work/bcdata/bcdata/vignettes"
```


## Geospatial Data in the B.C. Data Catalogue
The [B.C. Data Catalogue](https://catalogue.data.gov.bc.ca/dataset) provides many datasets with spatial information through a [Web Service](https://www2.gov.bc.ca/gov/content?id=95D78D544B244F34B89223EF069DF74E). Technically speaking, this means if we have an internet connection we can issue [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) requests to the catalogue and seamlessly import the response data into R as an `sf` objects. The `bcdata` package provides a means to a) choose which layer you want and b) use `dplyr` verbs to specifically tailor your request.  A `dbplyr` backend is implemented so that requests are executed lazily meaning results are not transferred over the web until the user specifically calls the `collect` function. This approach mimics the `dplyr` verb translation to `SQL` seen for many database types. A good introduction to principles of `dbplyr` is available [here](https://cran.r-project.org/package=dbplyr/vignettes/dbplyr.html).

## School District Data
Our first step is to extract the [school district polygons](https://catalog.data.gov.bc.ca/dataset/78ec5279-4534-49a1-97e8-9d315936f08b) from the B.C. Data Catalogue. This layer is described using this command:


```r
bcdc_get_record("78ec5279-4534-49a1-97e8-9d315936f08b")
#> [34m[1mB.C. Data Catalogue Record:[22m[39m School Districts of BC 
#> [34m[3m
#> Name:[23m[39m school-districts-of-bc (ID: 78ec5279-4534-49a1-97e8-9d315936f08b )[34m[3m
#> Permalink:[23m[39m https://catalogue.data.gov.bc.ca/dataset/78ec5279-4534-49a1-97e8-9d315936f08b[34m[3m
#> Sector:[23m[39m Education[34m[3m
#> Licence:[23m[39m Open Government Licence - British Columbia[34m[3m
#> Type:[23m[39m Geographic[34m[3m
#> Last Updated:[23m[39m 2019-12-17 
#> [34m[3m
#> Description:[23m[39m The School Districts dataset contains the spatial representation (polygon) of the
#> current extent of the administrative areas defined under section 176(1) of the
#> School Act for the purposes of preservation and promotion of the fundamental
#> principle of local autonomy and control of public education at the public and
#> governmental levels through locally elected school boards. 
#> [34m[3m
#> Resources: (3)
#> [23m[39m[90m# A tibble: 3 x 8[39m
#>   name     url        id      format ext   package_id  location bcdata_available
#>   [3m[90m<chr>[39m[23m    [3m[90m<chr>[39m[23m      [3m[90m<chr>[39m[23m   [3m[90m<chr>[39m[23m  [3m[90m<chr>[39m[23m [3m[90m<chr>[39m[23m       [3m[90m<chr>[39m[23m    [3m[90m<lgl>[39m[23m           
#> [90m1[39m BC Geogâ€¦ https://câ€¦ 529507â€¦ other  [90m"[39m[90m"[39m    78ec5279-4â€¦ bcgeogrâ€¦ FALSE           
#> [90m2[39m WMS getâ€¦ https://oâ€¦ 57d884â€¦ wms    [90m"[39m[90m"[39m    78ec5279-4â€¦ bcgeogrâ€¦ TRUE            
#> [90m3[39m KML Netâ€¦ http://opâ€¦ 7493e7â€¦ kml    [90m"[39mkml[90m"[39m 78ec5279-4â€¦ bcgeogrâ€¦ FALSE           
#> [34m
#> You can access the 'Resources' data frame using bcdc_tidy_resources()
#> 
#> [39m
```

This data is the boundary of each school district. The key information in this metadata is that the layer is a `**WFS request (Spatial Data)**`---which means it is available through a [Web Service](https://www2.gov.bc.ca/gov/content?id=95D78D544B244F34B89223EF069DF74E). From this we know we can make use of `bcdc_query_geodata`.


```r
bcdc_query_geodata("78ec5279-4534-49a1-97e8-9d315936f08b")
#> Querying [31m'school-districts-of-bc'[39m record
#> â— Using [34mcollect()[39m on this object will return [32m59[39m features and [32m9[39m fields
#> â— At most six rows of the record are printed here
#> â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#> Simple feature collection with 6 features and 9 fields
#> geometry type:  POLYGON
#> dimension:      XY
#> bbox:           xmin: 1480584 ymin: 475225.2 xmax: 1870586 ymax: 862609.6
#> epsg (SRID):    3005
#> proj4string:    +proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
#> [90m# A tibble: 6 x 10[39m
#>   id    ADMIN_AREA_SID SCHOOL_DISTRICTâ€¦ SCHOOL_DISTRICTâ€¦ FEATURE_CODE
#>   [3m[90m<chr>[39m[23m          [3m[90m<int>[39m[23m [3m[90m<chr>[39m[23m                       [3m[90m<int>[39m[23m [3m[90m<chr>[39m[23m       
#> [90m1[39m WHSEâ€¦            121 Southeast Kooteâ€¦                5 FA91800600  
#> [90m2[39m WHSEâ€¦            122 Rocky Mountain                  6 FA91800600  
#> [90m3[39m WHSEâ€¦            123 Kootenay Lake                   8 FA91800600  
#> [90m4[39m WHSEâ€¦            124 Arrow Lakes                    10 FA91800600  
#> [90m5[39m WHSEâ€¦            125 Revelstoke                     19 FA91800600  
#> [90m6[39m WHSEâ€¦            126 Kootenay-Columbâ€¦               20 FA91800600  
#> [90m# â€¦ with 5 more variables: FEATURE_AREA_SQM [3m[90m<dbl>[90m[23m, FEATURE_LENGTH_M [3m[90m<dbl>[90m[23m,
#> #   OBJECTID [3m[90m<int>[90m[23m, SE_ANNO_CAD_DATA [3m[90m<chr>[90m[23m, geometry [3m[90m<POLYGON [m]>[90m[23m[39m
```

This is the initial query to the data in the catalogue. What has been returned is *not* the actual data but rather a subset to help you tune your query. The printed output of this query offers several useful pieces of information. Because we have queried with a unique ID, we are shown the name of the record. We also receive instruction that using `collect()` will retrieve a given number of features and fields present for this query. Lastly, there is a reminder that what is printed is only the first 6 rows of the record. Since we are limiting the scope of analysis to the Greater Victoria, Prince George and Kamloops/Thompson school districts, we want to ask the catalogue for only those polygons just like we would in a typical `dplyr` workflow:


```r
bcdc_query_geodata("78ec5279-4534-49a1-97e8-9d315936f08b") %>%
  filter(SCHOOL_DISTRICT_NAME %in% c("Greater Victoria", "Prince George","Kamloops/Thompson"))
#> Querying [31m'school-districts-of-bc'[39m record
#> â— Using [34mcollect()[39m on this object will return [32m3[39m features and [32m9[39m fields
#> â— At most six rows of the record are printed here
#> â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#> Simple feature collection with 3 features and 9 fields
#> geometry type:  MULTIPOLYGON
#> dimension:      XY
#> bbox:           xmin: 1126991 ymin: 379215.8 xmax: 1528154 ymax: 1224041
#> epsg (SRID):    3005
#> proj4string:    +proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
#> [90m# A tibble: 3 x 10[39m
#>   id    ADMIN_AREA_SID SCHOOL_DISTRICTâ€¦ SCHOOL_DISTRICTâ€¦ FEATURE_CODE
#>   [3m[90m<chr>[39m[23m          [3m[90m<int>[39m[23m [3m[90m<chr>[39m[23m                       [3m[90m<int>[39m[23m [3m[90m<chr>[39m[23m       
#> [90m1[39m WHSEâ€¦            133 Prince George                  57 FA91800600  
#> [90m2[39m WHSEâ€¦            157 Greater Victoria               61 FA91800600  
#> [90m3[39m WHSEâ€¦            167 Kamloops/Thompsâ€¦               73 FA91800600  
#> [90m# â€¦ with 5 more variables: FEATURE_AREA_SQM [3m[90m<dbl>[90m[23m, FEATURE_LENGTH_M [3m[90m<dbl>[90m[23m,
#> #   OBJECTID [3m[90m<int>[90m[23m, SE_ANNO_CAD_DATA [3m[90m<chr>[90m[23m, geometry [3m[90m<MULTIPOLYGON [m]>[90m[23m[39m
```

To further tune our query, we can also request only the columns we want. Really we only want the school district column and the spatial information. During an actual analysis, it is possible that you may need to initially collect more data than you want to determine value to subset by. For example, there is currently no way to ask the catalogue for all possible unique values of `SCHOOL_DISTRICT_NAME`. Is that case the data will need to be brought into R and unique values will need to be determined there.


```r
bcdc_query_geodata("78ec5279-4534-49a1-97e8-9d315936f08b") %>%
  filter(SCHOOL_DISTRICT_NAME %in% c("Greater Victoria", "Prince George","Kamloops/Thompson")) %>%
  select(SCHOOL_DISTRICT_NAME)
#> Querying [31m'school-districts-of-bc'[39m record
#> â— Using [34mcollect()[39m on this object will return [32m3[39m features and [32m5[39m fields
#> â— At most six rows of the record are printed here
#> â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#> Simple feature collection with 3 features and 5 fields
#> geometry type:  MULTIPOLYGON
#> dimension:      XY
#> bbox:           xmin: 1126991 ymin: 379215.8 xmax: 1528154 ymax: 1224041
#> epsg (SRID):    3005
#> proj4string:    +proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
#> [90m# A tibble: 3 x 6[39m
#>   id    ADMIN_AREA_SID SCHOOL_DISTRICTâ€¦ SCHOOL_DISTRICTâ€¦ OBJECTID
#>   [3m[90m<chr>[39m[23m          [3m[90m<int>[39m[23m [3m[90m<chr>[39m[23m                       [3m[90m<int>[39m[23m    [3m[90m<int>[39m[23m
#> [90m1[39m WHSEâ€¦            133 Prince George                  57       13
#> [90m2[39m WHSEâ€¦            157 Greater Victoria               61       37
#> [90m3[39m WHSEâ€¦            167 Kamloops/Thompsâ€¦               73       47
#> [90m# â€¦ with 1 more variable: geometry [3m[90m<MULTIPOLYGON [m]>[90m[23m[39m
```

Note that in the `select` statement, we did not explicitly ask for the spatial data and also that there are several columns present that we didn't select. This is because within each dataset in the data catalogue, there are several columns that will always be returned regardless of what is selected. If you really don't want those columns after you `collect` the data, which we will take care of right now, you can drop them:


```r
districts <- bcdc_query_geodata("78ec5279-4534-49a1-97e8-9d315936f08b") %>%
  filter(SCHOOL_DISTRICT_NAME %in% c("Greater Victoria", "Prince George","Kamloops/Thompson")) %>%
  select(SCHOOL_DISTRICT_NAME) %>%
  collect()
```

Again note here that we have assigned the object a name and added the `collect` statement. This step happens when you have selected the data you want and wish to begin working with it in R like a normal `sf` object. For example, we can now plot these three school districts:


```r
plot(st_geometry(districts))
```

![plot of chunk districts](vignette-fig-districts-1.png)

Now that we have the spatial boundaries narrowed by specific school districts we can perform some spatial operations to determine parks in the school districts.

## Greenspaces Data
For the purposes of this example, let's consider [this greenspace](https://catalogue.data.gov.bc.ca/dataset/6a2fea1b-0cc4-4fc2-8017-eaf755d516da) layer in the catalogue. This layer is described here:


```r
bcdc_get_record("6a2fea1b-0cc4-4fc2-8017-eaf755d516da")
#> [34m[1mB.C. Data Catalogue Record:[22m[39m Local and Regional Greenspaces 
#> [34m[3m
#> Name:[23m[39m local-and-regional-greenspaces (ID: 6a2fea1b-0cc4-4fc2-8017-eaf755d516da )[34m[3m
#> Permalink:[23m[39m https://catalogue.data.gov.bc.ca/dataset/6a2fea1b-0cc4-4fc2-8017-eaf755d516da[34m[3m
#> Sector:[23m[39m Natural Resources[34m[3m
#> Licence:[23m[39m Open Government Licence - British Columbia[34m[3m
#> Type:[23m[39m Geographic[34m[3m
#> Last Updated:[23m[39m 2019-12-17 
#> [34m[3m
#> Description:[23m[39m This dataset contains spatial and attribute information for local and regional
#> greenspaces in British Columbia. Local and regional greenspaces are municipal or
#> regional district lands designated by local government agencies and managed for
#> public enjoyment, ecosystem or wildlife values. Spatial boundaries were sourced from
#> municipal and regional district web sites, which in some cases provide datasets
#> under Open Government Licence, and in other cases, publicize parks and greenspaces
#> on web maps or pdf maps. Boundaries were edge-matched to the ParcelMap BC cadastre.
#> This spatial layer contains multipart polygons. 
#> [34m[3m
#> Resources: (4)
#> [23m[39m[90m# A tibble: 4 x 8[39m
#>   name     url        id      format ext   package_id  location bcdata_available
#>   [3m[90m<chr>[39m[23m    [3m[90m<chr>[39m[23m      [3m[90m<chr>[39m[23m   [3m[90m<chr>[39m[23m  [3m[90m<chr>[39m[23m [3m[90m<chr>[39m[23m       [3m[90m<chr>[39m[23m    [3m[90m<lgl>[39m[23m           
#> [90m1[39m BC Geogâ€¦ https://câ€¦ dac897â€¦ other  [90m"[39m[90m"[39m    6a2fea1b-0â€¦ bcgwdatâ€¦ FALSE           
#> [90m2[39m WMS getâ€¦ https://oâ€¦ a8d5b5â€¦ wms    [90m"[39m[90m"[39m    6a2fea1b-0â€¦ bcgeogrâ€¦ TRUE            
#> [90m3[39m KML Netâ€¦ http://opâ€¦ a7454eâ€¦ kml    [90m"[39mkml[90m"[39m 6a2fea1b-0â€¦ bcgeogrâ€¦ FALSE           
#> [90m4[39m LocalReâ€¦ https://câ€¦ 766631â€¦ xlsx   [90m"[39mxlsâ€¦ 6a2fea1b-0â€¦ external TRUE            
#> [34m
#> You can access the 'Resources' data frame using bcdc_tidy_resources()
#> 
#> [39m
```

Again we recognize this is [Web Service-enabled](https://www2.gov.bc.ca/gov/content?id=95D78D544B244F34B89223EF069DF74E) geospatial data, which means we can make use of `bcdc_query_geodata`.


```r
bcdc_query_geodata("6a2fea1b-0cc4-4fc2-8017-eaf755d516da")
#> Querying [31m'local-and-regional-greenspaces'[39m record
#> â— Using [34mcollect()[39m on this object will return [32m8707[39m features and [32m19[39m fields
#> â— At most six rows of the record are printed here
#> â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#> Simple feature collection with 6 features and 19 fields
#> geometry type:  MULTIPOLYGON
#> dimension:      XY
#> bbox:           xmin: 1227676 ymin: 451802.2 xmax: 1236544 ymax: 467135.4
#> epsg (SRID):    3005
#> proj4string:    +proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
#> [90m# A tibble: 6 x 20[39m
#>   id    LOCAL_REG_GREENâ€¦ PARK_NAME PARK_TYPE PARK_PRIMARY_USE REGIONAL_DISTRIâ€¦
#>   [3m[90m<chr>[39m[23m            [3m[90m<int>[39m[23m [3m[90m<chr>[39m[23m     [3m[90m<chr>[39m[23m     [3m[90m<chr>[39m[23m            [3m[90m<chr>[39m[23m           
#> [90m1[39m WHSEâ€¦               19 55F - Grâ€¦ Local     Green Space      Metro Vancouver 
#> [90m2[39m WHSEâ€¦               20 50B - Utâ€¦ Local     Park             Metro Vancouver 
#> [90m3[39m WHSEâ€¦               21 Bear Creâ€¦ Local     Park             Metro Vancouver 
#> [90m4[39m WHSEâ€¦               22 Beaver Câ€¦ Local     Park             Metro Vancouver 
#> [90m5[39m WHSEâ€¦               23 Bel-Air â€¦ Local     Park             Metro Vancouver 
#> [90m6[39m WHSEâ€¦               24 Bell Estâ€¦ Local     Park             Metro Vancouver 
#> [90m# â€¦ with 14 more variables: MUNICIPALITY [3m[90m<chr>[90m[23m, CIVIC_NUMBER [3m[90m<int>[90m[23m,
#> #   CIVIC_NUMBER_SUFFIX [3m[90m<chr>[90m[23m, STREET_NAME [3m[90m<chr>[90m[23m, LATITUDE [3m[90m<dbl>[90m[23m,
#> #   LONGITUDE [3m[90m<dbl>[90m[23m, WHEN_UPDATED [3m[90m<date>[90m[23m, WEBSITE_URL [3m[90m<chr>[90m[23m,
#> #   LICENCE_COMMENTS [3m[90m<chr>[90m[23m, FEATURE_AREA_SQM [3m[90m<dbl>[90m[23m, FEATURE_LENGTH_M [3m[90m<dbl>[90m[23m,
#> #   OBJECTID [3m[90m<int>[90m[23m, SE_ANNO_CAD_DATA [3m[90m<chr>[90m[23m, geometry [3m[90m<MULTIPOLYGON [m]>[90m[23m[39m
```

Since we are interested in only "Park" data we can subset our query:


```r
bcdc_query_geodata("6a2fea1b-0cc4-4fc2-8017-eaf755d516da") %>%
  filter(PARK_PRIMARY_USE == "Park")
#> Querying [31m'local-and-regional-greenspaces'[39m record
#> â— Using [34mcollect()[39m on this object will return [32m4373[39m features and [32m19[39m fields
#> â— At most six rows of the record are printed here
#> â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#> Simple feature collection with 6 features and 19 fields
#> geometry type:  MULTIPOLYGON
#> dimension:      XY
#> bbox:           xmin: 1227676 ymin: 451450.3 xmax: 1234629 ymax: 467135.4
#> epsg (SRID):    3005
#> proj4string:    +proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
#> [90m# A tibble: 6 x 20[39m
#>   id    LOCAL_REG_GREENâ€¦ PARK_NAME PARK_TYPE PARK_PRIMARY_USE REGIONAL_DISTRIâ€¦
#>   [3m[90m<chr>[39m[23m            [3m[90m<int>[39m[23m [3m[90m<chr>[39m[23m     [3m[90m<chr>[39m[23m     [3m[90m<chr>[39m[23m            [3m[90m<chr>[39m[23m           
#> [90m1[39m WHSEâ€¦               20 50B - Utâ€¦ Local     Park             Metro Vancouver 
#> [90m2[39m WHSEâ€¦               21 Bear Creâ€¦ Local     Park             Metro Vancouver 
#> [90m3[39m WHSEâ€¦               22 Beaver Câ€¦ Local     Park             Metro Vancouver 
#> [90m4[39m WHSEâ€¦               23 Bel-Air â€¦ Local     Park             Metro Vancouver 
#> [90m5[39m WHSEâ€¦               24 Bell Estâ€¦ Local     Park             Metro Vancouver 
#> [90m6[39m WHSEâ€¦               25 Bell Park Local     Park             Metro Vancouver 
#> [90m# â€¦ with 14 more variables: MUNICIPALITY [3m[90m<chr>[90m[23m, CIVIC_NUMBER [3m[90m<int>[90m[23m,
#> #   CIVIC_NUMBER_SUFFIX [3m[90m<chr>[90m[23m, STREET_NAME [3m[90m<chr>[90m[23m, LATITUDE [3m[90m<dbl>[90m[23m,
#> #   LONGITUDE [3m[90m<dbl>[90m[23m, WHEN_UPDATED [3m[90m<date>[90m[23m, WEBSITE_URL [3m[90m<chr>[90m[23m,
#> #   LICENCE_COMMENTS [3m[90m<chr>[90m[23m, FEATURE_AREA_SQM [3m[90m<dbl>[90m[23m, FEATURE_LENGTH_M [3m[90m<dbl>[90m[23m,
#> #   OBJECTID [3m[90m<int>[90m[23m, SE_ANNO_CAD_DATA [3m[90m<chr>[90m[23m, geometry [3m[90m<MULTIPOLYGON [m]>[90m[23m[39m
```

Here we see that this greatly reduces the number of features that we are dealing with (and correspondingly the amount of data that needs to be transferred over the web). Remember also that we still have not actually requested the full dataset. This is just still a preview. Also this query still includes all municipal parks in BC while we only want the ones in the three school districts - the polygons defined by the `districts` object. To find that subset of parks we can make use of the built-in geometric operators which allow us to perform spatial operations remotely fine tuning our query even further. Here using the `INTERSECTS` function is appropriate and since this is a last tuning step, we can call `collect` and assign a name to this object. These requests can sometimes take quite a long:


```r
districts_parks <- bcdc_query_geodata("6a2fea1b-0cc4-4fc2-8017-eaf755d516da") %>%
  filter(PARK_PRIMARY_USE == "Park") %>%
  filter(INTERSECTS(districts)) %>%
  collect()
#> Warning: The object is too large to perform exact spatial operations using bcdata.
#>              To simplify the polygon, a bounding box was drawn around the polygon and all
#>              features within the box will be returned. Options include further processing
#>              with on the returned object or simplify the object.
```

Plotting both the filtered parks data and the district polygons reveals an important consideration when using `bcdata`:

![plot of chunk district_parks](vignette-fig-district_parks-1.png)

In this example, many parks not contained within the school districts are included in the `districts_parks` object. This is because rather than a full intersection, `bcdata` draws a bounding box around all the polygons that are doing the intersection (in this case `district`) and does the intersection based on that bounding box. This is a limitation imposed by the size of the object doing the geometric operation (in this case `district`) and the limits of the BC Data Catalogue. Drawing the bounding box illustrates this point:

![plot of chunk bbox](vignette-fig-bbox-1.png)

We are left with two options to get around this problem. First, we can simply do some additional processing with the `sf` package. Specifically we can use a spatial join to assign parks into their respective district:


```r
districts_parks_join <- districts_parks %>%
  st_join(districts, left = FALSE)
```

![plot of chunk dp_join](vignette-fig-dp_join-1.png)

A second approach is to set an internal option (`bcdata.max_geom_pred_size`) and increase the threshold of when a bounding box is drawn. Options are set in R like this:

```r
options("bcdata.max_geom_pred_size" = {object size in bytes})
```

The value of `bcdata.max_geom_pred_size` is set conservatively so that requests to the Web Service are more consistently successful. Increasing this value may result in invalid requests.

Finally, to address our original question of which school district has the most municipal park space we can calculate the area of each park polygon and then sum those areas by school district:


```r
districts_parks_join %>%
  mutate(area = st_area(geometry)) %>%
  st_set_geometry(NULL) %>%
  group_by(SCHOOL_DISTRICT_NAME) %>%
  summarise(total_area = sum(area)) %>%
  arrange(total_area)
#> [90m# A tibble: 3 x 2[39m
#>   SCHOOL_DISTRICT_NAME total_area
#>   [3m[90m<chr>[39m[23m                     [90m[m^2][39m
#> [90m1[39m Kamloops/Thompson       3982629
#> [90m2[39m Prince George          12254343
#> [90m3[39m Greater Victoria       25587503
```

## Additional Useful Functions
There are a couple of other functions in `bcdata` that are useful to know when working with spatial data from the catalogue. `bcdc_describe_feature` gives the column names, whether the column is selectable, and the column types in both R and on the remote server:


```r
bcdc_describe_feature("6a2fea1b-0cc4-4fc2-8017-eaf755d516da")
#> [90m# A tibble: 20 x 4[39m
#>    col_name                selectable remote_col_type          local_col_type
#>    [3m[90m<chr>[39m[23m                   [3m[90m<lgl>[39m[23m      [3m[90m<chr>[39m[23m                    [3m[90m<chr>[39m[23m         
#> [90m 1[39m id                      FALSE      xsd:string               character     
#> [90m 2[39m LOCAL_REG_GREENSPACE_ID FALSE      xsd:decimal              numeric       
#> [90m 3[39m PARK_NAME               TRUE       xsd:string               character     
#> [90m 4[39m PARK_TYPE               TRUE       xsd:string               character     
#> [90m 5[39m PARK_PRIMARY_USE        TRUE       xsd:string               character     
#> [90m 6[39m REGIONAL_DISTRICT       TRUE       xsd:string               character     
#> [90m 7[39m MUNICIPALITY            TRUE       xsd:string               character     
#> [90m 8[39m CIVIC_NUMBER            TRUE       xsd:decimal              numeric       
#> [90m 9[39m CIVIC_NUMBER_SUFFIX     TRUE       xsd:string               character     
#> [90m10[39m STREET_NAME             TRUE       xsd:string               character     
#> [90m11[39m LATITUDE                TRUE       xsd:decimal              numeric       
#> [90m12[39m LONGITUDE               TRUE       xsd:decimal              numeric       
#> [90m13[39m WHEN_UPDATED            TRUE       xsd:date                 date          
#> [90m14[39m WEBSITE_URL             TRUE       xsd:string               character     
#> [90m15[39m LICENCE_COMMENTS        TRUE       xsd:string               character     
#> [90m16[39m FEATURE_AREA_SQM        TRUE       xsd:decimal              numeric       
#> [90m17[39m FEATURE_LENGTH_M        TRUE       xsd:decimal              numeric       
#> [90m18[39m SHAPE                   TRUE       gml:GeometryPropertyType sfc geometry  
#> [90m19[39m OBJECTID                FALSE      xsd:decimal              numeric       
#> [90m20[39m SE_ANNO_CAD_DATA        TRUE       xsd:hexBinary            numeric
```

This is a helpful initial step to learn column names and types when you construct your query.

Another useful function is `show_query()` which provides information on the request issued to the remote server:


```r
bcdc_query_geodata("6a2fea1b-0cc4-4fc2-8017-eaf755d516da") %>%
  filter(PARK_PRIMARY_USE == "Park") %>%
  filter(INTERSECTS(districts)) %>%
  show_query()
#> Warning: The object is too large to perform exact spatial operations using bcdata.
#>              To simplify the polygon, a bounding box was drawn around the polygon and all
#>              features within the box will be returned. Options include further processing
#>              with on the returned object or simplify the object.
#> <url>
#> <body>
#>    SERVICE: WFS
#>    VERSION: 2.0.0
#>    REQUEST: GetFeature
#>    outputFormat: application/json
#>    typeNames: WHSE_BASEMAPPING.GBA_LOCAL_REG_GREENSPACES_SP
#>    SRSNAME: EPSG:3005
#>    CQL_FILTER: (("PARK_PRIMARY_USE" = 'Park') AND (INTERSECTS(SHAPE, POLYGON ((1126991 379215.8, 1528154 379215.8, 1528154 1224041, 1126991 1224041, 1126991 379215.8)))))
#> 
#> <full query url>
#> https://openmaps.gov.bc.ca/geo/pub/wfs?SERVICE=WFS&VERSION=2.0.0&REQUEST=GetFeature&outputFormat=application%2Fjson&typeNames=WHSE_BASEMAPPING.GBA_LOCAL_REG_GREENSPACES_SP&SRSNAME=EPSG%3A3005&CQL_FILTER=%28%28%22PARK_PRIMARY_USE%22%20%3D%20%27Park%27%29%20AND%20%28INTERSECTS%28SHAPE%2C%20POLYGON%20%28%281126991%20379215.8%2C%201528154%20379215.8%2C%201528154%201224041%2C%201126991%201224041%2C%201126991%20379215.8%29%29%29%29%29
```

This output is what being created by the dplyr code outlined above.

## Using B.C. Geographic Warehouse (BCGW) layer names

If you are familiar with the [B.C. Geographic Warehouse (BCGW)](https://www2.gov.bc.ca/gov/content/data/geographic-data-services/bc-spatial-data-infrastructure/bc-geographic-warehouse),
you may already know the name of a layer that you want from the BCGW.
`bcdc_query_geodata()` (as well as all other related functions)
supports supplying that name directly. For example, the
[record for the B.C. airports layer](https://catalogue.data.gov.bc.ca/dataset/bc-airports#object-description)
shows that the object name is `WHSE_IMAGERY_AND_BASE_MAPS.GSR_AIRPORTS_SVW`, and
we can use that in `bcdc_query_geodata()`:


```r
# Look at the columns available:
bcdc_describe_feature("WHSE_IMAGERY_AND_BASE_MAPS.GSR_AIRPORTS_SVW")
#> [90m# A tibble: 42 x 4[39m
#>    col_name                      selectable remote_col_type local_col_type
#>    [3m[90m<chr>[39m[23m                         [3m[90m<lgl>[39m[23m      [3m[90m<chr>[39m[23m           [3m[90m<chr>[39m[23m         
#> [90m 1[39m id                            FALSE      xsd:string      character     
#> [90m 2[39m CUSTODIAN_ORG_DESCRIPTION     FALSE      xsd:string      character     
#> [90m 3[39m BUSINESS_CATEGORY_CLASS       FALSE      xsd:string      character     
#> [90m 4[39m BUSINESS_CATEGORY_DESCRIPTION FALSE      xsd:string      character     
#> [90m 5[39m OCCUPANT_TYPE_DESCRIPTION     FALSE      xsd:string      character     
#> [90m 6[39m SOURCE_DATA_ID                FALSE      xsd:string      character     
#> [90m 7[39m SUPPLIED_SOURCE_ID_IND        FALSE      xsd:string      character     
#> [90m 8[39m AIRPORT_NAME                  FALSE      xsd:string      character     
#> [90m 9[39m DESCRIPTION                   TRUE       xsd:string      character     
#> [90m10[39m PHYSICAL_ADDRESS              TRUE       xsd:string      character     
#> [90m# â€¦ with 32 more rows[39m

# Query the data with bcdc_query_geodata and filter + select:
bcdc_query_geodata("WHSE_IMAGERY_AND_BASE_MAPS.GSR_AIRPORTS_SVW") %>%
  filter(DESCRIPTION == "airport") %>%
  select(AIRPORT_NAME, LOCALITY, NUMBER_OF_RUNWAYS)
#> Querying [31m'WHSE_IMAGERY_AND_BASE_MAPS.GSR_AIRPORTS_SVW'[39m record
#> â— Using [34mcollect()[39m on this object will return [32m37[39m features and [32m13[39m fields
#> â— At most six rows of the record are printed here
#> â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#> Simple feature collection with 6 features and 13 fields
#> geometry type:  POINT
#> dimension:      XY
#> bbox:           xmin: 833323.9 ymin: 406886.6 xmax: 1266385 ymax: 1054950
#> epsg (SRID):    3005
#> proj4string:    +proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
#> [90m# A tibble: 6 x 14[39m
#>   id    CUSTODIAN_ORG_Dâ€¦ BUSINESS_CATEGOâ€¦ BUSINESS_CATEGOâ€¦ OCCUPANT_TYPE_Dâ€¦
#>   [3m[90m<chr>[39m[23m [3m[90m<chr>[39m[23m            [3m[90m<chr>[39m[23m            [3m[90m<chr>[39m[23m            [3m[90m<chr>[39m[23m           
#> [90m1[39m WHSEâ€¦ [90m"[39mMinistry of Foâ€¦ airTransportatiâ€¦ Air Transportatâ€¦ BC Airports     
#> [90m2[39m WHSEâ€¦ [90m"[39mMinistry of Foâ€¦ airTransportatiâ€¦ Air Transportatâ€¦ BC Airports     
#> [90m3[39m WHSEâ€¦ [90m"[39mMinistry of Foâ€¦ airTransportatiâ€¦ Air Transportatâ€¦ BC Airports     
#> [90m4[39m WHSEâ€¦ [90m"[39mMinistry of Foâ€¦ airTransportatiâ€¦ Air Transportatâ€¦ BC Airports     
#> [90m5[39m WHSEâ€¦ [90m"[39mMinistry of Foâ€¦ airTransportatiâ€¦ Air Transportatâ€¦ BC Airports     
#> [90m6[39m WHSEâ€¦ [90m"[39mMinistry of Foâ€¦ airTransportatiâ€¦ Air Transportatâ€¦ BC Airports     
#> [90m# â€¦ with 9 more variables: SOURCE_DATA_ID [3m[90m<chr>[90m[23m, SUPPLIED_SOURCE_ID_IND [3m[90m<chr>[90m[23m,
#> #   AIRPORT_NAME [3m[90m<chr>[90m[23m, LOCALITY [3m[90m<chr>[90m[23m, LATITUDE [3m[90m<dbl>[90m[23m, LONGITUDE [3m[90m<dbl>[90m[23m,
#> #   NUMBER_OF_RUNWAYS [3m[90m<int>[90m[23m, SEQUENCE_ID [3m[90m<int>[90m[23m, geometry [3m[90m<POINT [m]>[90m[23m[39m
```
